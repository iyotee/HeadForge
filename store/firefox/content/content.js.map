{"version":3,"file":"content/content.js","mappings":"mBA4aA,IAzaA,MAIE,WAAAA,GAHQ,KAAAC,UAAoB,EACpB,KAAAC,cAAoC,KAG1CC,KAAKC,uBACLD,KAAKE,gBACLF,KAAKG,wBACP,CAEQ,oBAAAF,GACNG,OAAOC,QAAQC,UAAUC,YAAY,CAACC,EAAkBC,EAAQC,KAC9DV,KAAKW,cAAcH,EAASC,EAAQC,IAC7B,GAEX,CAEQ,mBAAMC,CAAcH,EAAkBC,EAAaC,GACzD,IACE,IAAIE,EAEJ,OAAQJ,EAAQK,MACd,IAAK,gBACHD,QAAiBZ,KAAKc,mBAAmBN,EAAQO,SACjD,MAEF,IAAK,gBACHH,QAAiBZ,KAAKgB,mBAAmBR,EAAQO,SACjD,MAEF,IAAK,gBACHH,QAAiBZ,KAAKiB,sBACtB,MAEF,QACEL,EAAW,CAAEM,MAAO,wBAGxBR,EAAaE,EACf,CAAE,MAAOM,GAEPR,EAAa,CAAEQ,MAAOA,aAAiBC,MAAQD,EAAMV,QAAU,iBACjE,CACF,CAEQ,wBAAMM,CAAmBC,GAC/B,IACE,MAAM,cAAEK,EAAa,SAAEC,GAAaN,EAEpC,IAAKf,KAAKD,cACR,MAAM,IAAIoB,MAAM,6BAMlB,OAFAnB,KAAKsB,mBAAmBF,GAEjB,CACLG,SAAS,EACTf,QAAS,+BAEb,CAAE,MAAOU,GACP,MAAO,CACLK,SAAS,EACTL,MAAOA,aAAiBC,MAAQD,EAAMV,QAAU,gBAEpD,CACF,CAEQ,wBAAMQ,CAAmBD,GAC/B,IACE,MAAM,MAAES,GAAUT,EAKlB,OAFAU,SAASC,gBAAgBC,aAAa,uBAAwBH,GAEvD,CAAED,SAAS,EACpB,CAAE,MAAOL,GACP,MAAO,CACLK,SAAS,EACTL,MAAOA,aAAiBC,MAAQD,EAAMV,QAAU,gBAEpD,CACF,CAEQ,yBAAMS,GACZ,IACE,MAAMW,EAAS5B,KAAK6B,mBAEpB,MAAO,CACLN,SAAS,EACTK,OAAQA,EAAS,CACff,KAAMb,KAAK8B,cAAcF,GACzBG,QAASH,EAAOI,QAChBC,GAAIL,EAAOK,GACXC,UAAWN,EAAOM,WAChB,KAER,CAAE,MAAOhB,GACP,MAAO,CACLK,SAAS,EACTL,MAAOA,aAAiBC,MAAQD,EAAMV,QAAU,gBAEpD,CACF,CAEQ,aAAAN,GAEN,MAAMiC,EAAkB,CAEtB,cACA,aAGA,iBAGA,cAGA,0BAGA,wBACA,4BAGA,6BAGA,mBACA,aAGA,gBAGA,WAGA,WAGA,4BAIe,IAAIC,iBAAkBC,IACrCA,EAAUC,QAASC,IACjBA,EAASC,WAAWF,QAASG,IAC3B,GAAIA,EAAKC,WAAaC,KAAKC,aAAc,CACvC,MAAMb,EAAUU,EAGZzC,KAAK6C,SAASd,IAChB/B,KAAK8C,YAAYf,GAInBI,EAAgBG,QAAQS,IACNhB,EAAQiB,iBAAiBD,GACjCT,QAAQV,IACd5B,KAAK8C,YAAYlB,MAGvB,QAKGqB,QAAQxB,SAASyB,KAAM,CAC9BC,WAAW,EACXC,SAAS,IAIXjB,EAAgBG,QAAQS,IACNtB,SAASuB,iBAAiBD,GAClCT,QAAQV,IACd5B,KAAK8C,YAAYlB,MAGvB,CAEQ,WAAAkB,CAAYlB,GAElBA,EAAOyB,iBAAiB,QAAS,KAC/BrD,KAAKD,cAAgB6B,EACrB5B,KAAKF,UAAW,IAGlB8B,EAAOyB,iBAAiB,OAAQ,KAC9BrD,KAAKF,UAAW,IAIlB8B,EAAOyB,iBAAiB,QAAS,KAC/BrD,KAAKD,cAAgB6B,EACrB5B,KAAKF,UAAW,IAIlB8B,EAAOyB,iBAAiB,UAAYC,IACpB,QAAVA,EAAEC,KAA2B,UAAVD,EAAEC,MACvBvD,KAAKD,cAAgB6B,EACrB5B,KAAKF,UAAW,IAGtB,CAEQ,QAAA+C,CAASd,GASf,GARoB,CAClB,WACA,MACA,OACA,+BAIcyB,SAASzB,EAAQC,QAAQyB,eACvC,OAAO,EAaT,MATsB,CACpB,aACA,YACA,gBACA,aACA,YACA,gBAGmBC,KAAKxB,GACxBH,EAAQ4B,UAAUC,SAAS1B,IAC3BH,EAAQG,UAAUsB,SAAStB,GAE/B,CAEQ,gBAAAL,GAEN,MAAMgC,EAAgBpC,SAASoC,cAC/B,GAAIA,GAAiB7D,KAAK6C,SAASgB,GACjC,OAAOA,EAIT,GAAI7D,KAAKD,eAAiBC,KAAK6C,SAAS7C,KAAKD,eAC3C,OAAOC,KAAKD,cAId,MAAMoC,EAAkB,CACtB,cACA,aACA,iBACA,cACA,WACA,4BAGF,IAAK,MAAMY,KAAYZ,EAAiB,CACtC,MAAM2B,EAAUrC,SAASuB,iBAAiBD,GAC1C,IAAK,MAAMnB,KAAUkC,EACnB,GAAI9D,KAAK6C,SAASjB,IAAW5B,KAAK+D,iBAAiBnC,GACjD,OAAOA,CAGb,CAEA,OAAO,IACT,CAEQ,gBAAAmC,CAAiBhC,GACvB,MAAMiC,EAAOjC,EAAQkC,wBACrB,OAAOD,EAAKE,MAAQ,GAAKF,EAAKG,OAAS,GAChCH,EAAKI,KAAO,GAAKJ,EAAKK,MAAQ,GAC9BL,EAAKM,QAAUC,OAAOC,aACtBR,EAAKS,OAASF,OAAOG,UAC9B,CAEQ,aAAA5C,CAAcF,GACpB,OAAIA,EAAO+B,UAAUC,SAAS,eAAiBhC,EAAO+B,UAAUC,SAAS,aAChE,aAELhC,EAAO+B,UAAUC,SAAS,iBACrB,SAELhC,EAAO+B,UAAUC,SAAS,cACrB,MAE4B,aAAjChC,EAAOI,QAAQyB,cACV,WAEsB,SAA3B7B,EAAO+C,gBACF,kBAEF,SACT,CAEQ,kBAAArD,CAAmBsD,GACzB,IAAK5E,KAAKD,cAAe,OAIzB,OAFmBC,KAAK8B,cAAc9B,KAAKD,gBAGzC,IAAK,aACHC,KAAK6E,qBAAqBD,GAC1B,MACF,IAAK,SACH5E,KAAK8E,iBAAiBF,GACtB,MACF,IAAK,MACH5E,KAAK+E,cAAcH,GACnB,MACF,IAAK,WACH5E,KAAKgF,mBAAmBJ,GACxB,MACF,IAAK,kBACH5E,KAAKiF,0BAA0BL,GAC/B,MACF,QACE5E,KAAKkF,kBAAkBN,GAE7B,CAEQ,oBAAAC,CAAqBD,GAE3B,MAAMO,EAAMnF,KAAKD,cAAsBqF,WACvC,GAAID,EAAI,CACN,MAAME,EAASF,EAAGG,YAClBH,EAAGI,aAAaX,EAAO,KAAMS,GAC7BF,EAAGK,OACL,CACF,CAEQ,gBAAAV,CAAiBF,GAEvB,MAAMhD,EAAU5B,KAAKD,cAAsB0F,eAC3C,GAAI7D,EAAQ,CACV,MAAM8D,EAAW9D,EAAO+D,cACxB/D,EAAOgE,aAAa,mBAAoB,CAAC,CACvCC,MAAO,CACLC,gBAAiBJ,EAASK,WAC1BC,YAAaN,EAASO,OACtBC,cAAeR,EAASK,WACxBI,UAAWT,EAASO,QAEtBrB,KAAMA,EAAO,KACbwB,kBAAkB,KAEpBxE,EAAO4D,OACT,CACF,CAEQ,aAAAT,CAAcH,GAEpB,MAAMhD,EAAU5B,KAAKD,cAAsBsG,KAAKzE,OAChD,GAAIA,EAAQ,CACV,MAAMyD,EAASzD,EAAO0E,oBACtB1E,EAAO2E,QAAQC,OAAOnB,EAAQT,EAAO,MACrChD,EAAO4D,OACT,CACF,CAEQ,kBAAAR,CAAmBJ,GACzB,MAAM6B,EAAWzG,KAAKD,cAChB2G,EAAQD,EAASE,eACjBC,EAAMH,EAASI,aACfC,EAAQL,EAASK,MAEvBL,EAASK,MAAQA,EAAMC,UAAU,EAAGL,GAAS9B,EAAO,KAAOkC,EAAMC,UAAUH,GAC3EH,EAASE,eAAiBF,EAASI,aAAeH,EAAQ9B,EAAKoC,OAAS,EACxEP,EAASjB,QAGTiB,EAASQ,cAAc,IAAIC,MAAM,QAAS,CAAEC,SAAS,IACvD,CAEQ,yBAAAlC,CAA0BL,GAChC,MAAMwC,EAAY7C,OAAO8C,eACzB,GAAID,GAAaA,EAAUE,WAAa,EAAG,CACzC,MAAMzB,EAAQuB,EAAUG,WAAW,GACnC1B,EAAM2B,iBAEN,MAAMC,EAAWhG,SAASiG,eAAe9C,EAAO,MAChDiB,EAAM8B,WAAWF,GAGjB5B,EAAM+B,cAAcH,GACpB5B,EAAMgC,YAAYJ,GAClBL,EAAUU,kBACVV,EAAUW,SAASlC,EACrB,CACF,CAEQ,iBAAAX,CAAkBN,GAEpB5E,KAAKD,eAAwD,SAAvCC,KAAKD,cAAc4E,gBAC3C3E,KAAKiF,0BAA0BL,GAG/B5E,KAAKgF,mBAAmBJ,EAE5B,CAEQ,sBAAAzE,GACNsB,SAAS4B,iBAAiB,UAAYC,KAE/BA,EAAE0E,SAAW1E,EAAE2E,UAAY3E,EAAE4E,UAAsB,MAAV5E,EAAEC,MAC9CD,EAAE6E,iBACFnI,KAAKoI,uBAGX,CAEQ,kBAAAA,GAENhI,OAAOC,QAAQgI,YAAY,CACzBxH,KAAM,cAEV,E","sources":["webpack://headforge/./src/content/content-script.ts"],"sourcesContent":["import { Message } from '@/types';\r\nimport { MESSAGE_TYPES } from '@/utils/constants';\r\n\r\nclass HeadForgeContentScript {\r\n  private isActive: boolean = false;\r\n  private currentEditor: HTMLElement | null = null;\r\n\r\n  constructor() {\r\n    this.setupMessageListener();\r\n    this.detectEditors();\r\n    this.setupKeyboardShortcuts();\r\n  }\r\n\r\n  private setupMessageListener(): void {\r\n    chrome.runtime.onMessage.addListener((message: Message, sender, sendResponse) => {\r\n      this.handleMessage(message, sender, sendResponse);\r\n      return true; // Keep message channel open for async response\r\n    });\r\n  }\r\n\r\n  private async handleMessage(message: Message, sender: any, sendResponse: (response?: any) => void): Promise<void> {\r\n    try {\r\n      let response: any;\r\n\r\n      switch (message.type) {\r\n        case 'INSERT_HEADER':\r\n          response = await this.handleInsertHeader(message.payload);\r\n          break;\r\n\r\n        case 'THEME_CHANGED':\r\n          response = await this.handleThemeChanged(message.payload);\r\n          break;\r\n\r\n        case 'DETECT_EDITOR':\r\n          response = await this.detectCurrentEditor();\r\n          break;\r\n\r\n        default:\r\n          response = { error: 'Unknown message type' };\r\n      }\r\n\r\n      sendResponse(response);\r\n    } catch (error) {\r\n      console.error('Error handling message:', error);\r\n      sendResponse({ error: error instanceof Error ? error.message : 'Unknown error' });\r\n    }\r\n  }\r\n\r\n  private async handleInsertHeader(payload: any): Promise<any> {\r\n    try {\r\n      const { headerContent, language } = payload;\r\n      \r\n      if (!this.currentEditor) {\r\n        throw new Error('No active editor detected');\r\n      }\r\n\r\n      // Insert header at the beginning of the editor\r\n      this.insertTextAtCursor(headerContent);\r\n      \r\n      return {\r\n        success: true,\r\n        message: 'Header inserted successfully'\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  private async handleThemeChanged(payload: any): Promise<any> {\r\n    try {\r\n      const { theme } = payload;\r\n      \r\n      // Update theme for any injected UI elements\r\n      document.documentElement.setAttribute('data-headforge-theme', theme);\r\n      \r\n      return { success: true };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  private async detectCurrentEditor(): Promise<any> {\r\n    try {\r\n      const editor = this.findActiveEditor();\r\n      \r\n      return {\r\n        success: true,\r\n        editor: editor ? {\r\n          type: this.getEditorType(editor),\r\n          element: editor.tagName,\r\n          id: editor.id,\r\n          className: editor.className\r\n        } : null\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      };\r\n    }\r\n  }\r\n\r\n  private detectEditors(): void {\r\n    // Common editor selectors\r\n    const editorSelectors = [\r\n      // CodeMirror\r\n      '.CodeMirror',\r\n      '.cm-editor',\r\n      \r\n      // Monaco Editor\r\n      '.monaco-editor',\r\n      \r\n      // Ace Editor\r\n      '.ace_editor',\r\n      \r\n      // Prism.js\r\n      'pre[class*=\"language-\"]',\r\n      \r\n      // Generic code editors\r\n      'textarea[data-editor]',\r\n      'textarea[class*=\"editor\"]',\r\n      \r\n      // VS Code Web\r\n      '.monaco-editor .view-lines',\r\n      \r\n      // GitHub\r\n      '.blob-code-inner',\r\n      '.blob-code',\r\n      \r\n      // GitLab\r\n      '.file-content',\r\n      \r\n      // Stack Overflow\r\n      'pre code',\r\n      \r\n      // Generic textareas\r\n      'textarea',\r\n      \r\n      // Contenteditable\r\n      '[contenteditable=\"true\"]'\r\n    ];\r\n\r\n    // Use MutationObserver to detect dynamically added editors\r\n    const observer = new MutationObserver((mutations) => {\r\n      mutations.forEach((mutation) => {\r\n        mutation.addedNodes.forEach((node) => {\r\n          if (node.nodeType === Node.ELEMENT_NODE) {\r\n            const element = node as Element;\r\n            \r\n            // Check if the added element is an editor\r\n            if (this.isEditor(element)) {\r\n              this.setupEditor(element as HTMLElement);\r\n            }\r\n            \r\n            // Check if the added element contains editors\r\n            editorSelectors.forEach(selector => {\r\n              const editors = element.querySelectorAll(selector);\r\n              editors.forEach(editor => {\r\n                this.setupEditor(editor as HTMLElement);\r\n              });\r\n            });\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    observer.observe(document.body, {\r\n      childList: true,\r\n      subtree: true\r\n    });\r\n\r\n    // Setup existing editors\r\n    editorSelectors.forEach(selector => {\r\n      const editors = document.querySelectorAll(selector);\r\n      editors.forEach(editor => {\r\n        this.setupEditor(editor as HTMLElement);\r\n      });\r\n    });\r\n  }\r\n\r\n  private setupEditor(editor: HTMLElement): void {\r\n    // Add focus listener to track active editor\r\n    editor.addEventListener('focus', () => {\r\n      this.currentEditor = editor;\r\n      this.isActive = true;\r\n    });\r\n\r\n    editor.addEventListener('blur', () => {\r\n      this.isActive = false;\r\n    });\r\n\r\n    // Add click listener for click-to-focus\r\n    editor.addEventListener('click', () => {\r\n      this.currentEditor = editor;\r\n      this.isActive = true;\r\n    });\r\n\r\n    // Add keyboard listener for keyboard navigation\r\n    editor.addEventListener('keydown', (e) => {\r\n      if (e.key === 'Tab' || e.key === 'Enter') {\r\n        this.currentEditor = editor;\r\n        this.isActive = true;\r\n      }\r\n    });\r\n  }\r\n\r\n  private isEditor(element: Element): boolean {\r\n    const editorTypes = [\r\n      'textarea',\r\n      'pre',\r\n      'code',\r\n      'div[contenteditable=\"true\"]'\r\n    ];\r\n\r\n    // Check tag name\r\n    if (editorTypes.includes(element.tagName.toLowerCase())) {\r\n      return true;\r\n    }\r\n\r\n    // Check for editor-specific classes\r\n    const editorClasses = [\r\n      'CodeMirror',\r\n      'cm-editor',\r\n      'monaco-editor',\r\n      'ace_editor',\r\n      'blob-code',\r\n      'file-content'\r\n    ];\r\n\r\n    return editorClasses.some(className => \r\n      element.classList.contains(className) || \r\n      element.className.includes(className)\r\n    );\r\n  }\r\n\r\n  private findActiveEditor(): HTMLElement | null {\r\n    // First, try to find the currently focused element\r\n    const activeElement = document.activeElement as HTMLElement;\r\n    if (activeElement && this.isEditor(activeElement)) {\r\n      return activeElement;\r\n    }\r\n\r\n    // Then, try to find the last focused editor\r\n    if (this.currentEditor && this.isEditor(this.currentEditor)) {\r\n      return this.currentEditor;\r\n    }\r\n\r\n    // Finally, try to find any visible editor\r\n    const editorSelectors = [\r\n      '.CodeMirror',\r\n      '.cm-editor',\r\n      '.monaco-editor',\r\n      '.ace_editor',\r\n      'textarea',\r\n      '[contenteditable=\"true\"]'\r\n    ];\r\n\r\n    for (const selector of editorSelectors) {\r\n      const editors = document.querySelectorAll(selector);\r\n      for (const editor of editors) {\r\n        if (this.isEditor(editor) && this.isElementVisible(editor as HTMLElement)) {\r\n          return editor as HTMLElement;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  private isElementVisible(element: HTMLElement): boolean {\r\n    const rect = element.getBoundingClientRect();\r\n    return rect.width > 0 && rect.height > 0 && \r\n           rect.top >= 0 && rect.left >= 0 &&\r\n           rect.bottom <= window.innerHeight && \r\n           rect.right <= window.innerWidth;\r\n  }\r\n\r\n  private getEditorType(editor: HTMLElement): string {\r\n    if (editor.classList.contains('CodeMirror') || editor.classList.contains('cm-editor')) {\r\n      return 'codemirror';\r\n    }\r\n    if (editor.classList.contains('monaco-editor')) {\r\n      return 'monaco';\r\n    }\r\n    if (editor.classList.contains('ace_editor')) {\r\n      return 'ace';\r\n    }\r\n    if (editor.tagName.toLowerCase() === 'textarea') {\r\n      return 'textarea';\r\n    }\r\n    if (editor.contentEditable === 'true') {\r\n      return 'contenteditable';\r\n    }\r\n    return 'unknown';\r\n  }\r\n\r\n  private insertTextAtCursor(text: string): void {\r\n    if (!this.currentEditor) return;\r\n\r\n    const editorType = this.getEditorType(this.currentEditor);\r\n\r\n    switch (editorType) {\r\n      case 'codemirror':\r\n        this.insertIntoCodeMirror(text);\r\n        break;\r\n      case 'monaco':\r\n        this.insertIntoMonaco(text);\r\n        break;\r\n      case 'ace':\r\n        this.insertIntoAce(text);\r\n        break;\r\n      case 'textarea':\r\n        this.insertIntoTextarea(text);\r\n        break;\r\n      case 'contenteditable':\r\n        this.insertIntoContentEditable(text);\r\n        break;\r\n      default:\r\n        this.insertIntoGeneric(text);\r\n    }\r\n  }\r\n\r\n  private insertIntoCodeMirror(text: string): void {\r\n    // CodeMirror API\r\n    const cm = (this.currentEditor as any).CodeMirror;\r\n    if (cm) {\r\n      const cursor = cm.getCursor();\r\n      cm.replaceRange(text + '\\n', cursor);\r\n      cm.focus();\r\n    }\r\n  }\r\n\r\n  private insertIntoMonaco(text: string): void {\r\n    // Monaco Editor API\r\n    const editor = (this.currentEditor as any).__monacoEditor;\r\n    if (editor) {\r\n      const position = editor.getPosition();\r\n      editor.executeEdits('headforge-insert', [{\r\n        range: {\r\n          startLineNumber: position.lineNumber,\r\n          startColumn: position.column,\r\n          endLineNumber: position.lineNumber,\r\n          endColumn: position.column\r\n        },\r\n        text: text + '\\n',\r\n        forceMoveMarkers: true\r\n      }]);\r\n      editor.focus();\r\n    }\r\n  }\r\n\r\n  private insertIntoAce(text: string): void {\r\n    // Ace Editor API\r\n    const editor = (this.currentEditor as any).env?.editor;\r\n    if (editor) {\r\n      const cursor = editor.getCursorPosition();\r\n      editor.session.insert(cursor, text + '\\n');\r\n      editor.focus();\r\n    }\r\n  }\r\n\r\n  private insertIntoTextarea(text: string): void {\r\n    const textarea = this.currentEditor as HTMLTextAreaElement;\r\n    const start = textarea.selectionStart;\r\n    const end = textarea.selectionEnd;\r\n    const value = textarea.value;\r\n    \r\n    textarea.value = value.substring(0, start) + text + '\\n' + value.substring(end);\r\n    textarea.selectionStart = textarea.selectionEnd = start + text.length + 1;\r\n    textarea.focus();\r\n    \r\n    // Trigger input event\r\n    textarea.dispatchEvent(new Event('input', { bubbles: true }));\r\n  }\r\n\r\n  private insertIntoContentEditable(text: string): void {\r\n    const selection = window.getSelection();\r\n    if (selection && selection.rangeCount > 0) {\r\n      const range = selection.getRangeAt(0);\r\n      range.deleteContents();\r\n      \r\n      const textNode = document.createTextNode(text + '\\n');\r\n      range.insertNode(textNode);\r\n      \r\n      // Move cursor after inserted text\r\n      range.setStartAfter(textNode);\r\n      range.setEndAfter(textNode);\r\n      selection.removeAllRanges();\r\n      selection.addRange(range);\r\n    }\r\n  }\r\n\r\n  private insertIntoGeneric(text: string): void {\r\n    // Fallback method\r\n    if (this.currentEditor && this.currentEditor.contentEditable === 'true') {\r\n      this.insertIntoContentEditable(text);\r\n    } else {\r\n      // Try to insert as if it's a textarea\r\n      this.insertIntoTextarea(text);\r\n    }\r\n  }\r\n\r\n  private setupKeyboardShortcuts(): void {\r\n    document.addEventListener('keydown', (e) => {\r\n      // Check for HeadForge shortcuts (Ctrl/Cmd + Shift + H)\r\n      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'H') {\r\n        e.preventDefault();\r\n        this.openHeadForgePopup();\r\n      }\r\n    });\r\n  }\r\n\r\n  private openHeadForgePopup(): void {\r\n    // Send message to background script to open popup\r\n    chrome.runtime.sendMessage({\r\n      type: 'OPEN_POPUP'\r\n    });\r\n  }\r\n\r\n}\r\n\r\n// Initialize the content script\r\nnew HeadForgeContentScript();\r\n"],"names":["constructor","isActive","currentEditor","this","setupMessageListener","detectEditors","setupKeyboardShortcuts","chrome","runtime","onMessage","addListener","message","sender","sendResponse","handleMessage","response","type","handleInsertHeader","payload","handleThemeChanged","detectCurrentEditor","error","Error","headerContent","language","insertTextAtCursor","success","theme","document","documentElement","setAttribute","editor","findActiveEditor","getEditorType","element","tagName","id","className","editorSelectors","MutationObserver","mutations","forEach","mutation","addedNodes","node","nodeType","Node","ELEMENT_NODE","isEditor","setupEditor","selector","querySelectorAll","observe","body","childList","subtree","addEventListener","e","key","includes","toLowerCase","some","classList","contains","activeElement","editors","isElementVisible","rect","getBoundingClientRect","width","height","top","left","bottom","window","innerHeight","right","innerWidth","contentEditable","text","insertIntoCodeMirror","insertIntoMonaco","insertIntoAce","insertIntoTextarea","insertIntoContentEditable","insertIntoGeneric","cm","CodeMirror","cursor","getCursor","replaceRange","focus","__monacoEditor","position","getPosition","executeEdits","range","startLineNumber","lineNumber","startColumn","column","endLineNumber","endColumn","forceMoveMarkers","env","getCursorPosition","session","insert","textarea","start","selectionStart","end","selectionEnd","value","substring","length","dispatchEvent","Event","bubbles","selection","getSelection","rangeCount","getRangeAt","deleteContents","textNode","createTextNode","insertNode","setStartAfter","setEndAfter","removeAllRanges","addRange","ctrlKey","metaKey","shiftKey","preventDefault","openHeadForgePopup","sendMessage"],"sourceRoot":""}